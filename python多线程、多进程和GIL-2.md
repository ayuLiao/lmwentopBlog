---
title: python多线程、多进程和GIL(2)
date: 2017-07-18 10:32:22
tags: python
---

## 简介
接着上一说，上一篇已经讲了线程和进程、python中如何使用多线程和多进程了，没有看的，现在可以回去看看

[python多线程、多进程和GIL](http://lmwen.top/2017/07/17/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8CGIL/)

本篇，来聊聊GIL，弄明白上一篇的留下的问题：python中无法实现真正的多线程？

## python中无法实现真正的多线程？

我们用代码来理解这个问题
首先我的电脑是4核的，那么我开一个线程让其进入死循环，理论上就会占满我cpu中的一个核，代码和结果如图

![python死循环.png](http://obfs4iize.bkt.clouddn.com/python%E6%AD%BB%E5%BE%AA%E7%8E%AF.png)

从图中可以看出，占了25%的cpu，刚好是一核

那么我启用两个线程，应该会占50%，也就是两个核，如图

![python双线程死循环.png](http://obfs4iize.bkt.clouddn.com/python%E5%8F%8C%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF.png)

通过threading开启了一个线程，并进入死循环，同时主线程也调用dead_loop()进入死循环，此时两个线程都进入了死循环，但是cpu依旧占25%左右

其实开100个线程进入死循环也一样，cpu依旧占25%，可以看出python中开多线程的几乎是无意义的，因为无法使用多核cpu，提高不了效率，还不如写一个线程呢

为何会有这样的现象？GIL是罪魁祸首

## What is GIL

GIL是什么？

一句话概括，**GIL就是CPython解释器中的一个全局锁**，这句话的含义有
(1)GIL不是Python这个语言的特性，是CPython这个python解释器的特性，JPython、PyPy等python解释器中是没有GIL这个东西的
(2)GIL是个锁，锁的特性大家应该都清澈，只有获得锁的对象才可以被执行

那么问题就来了

首先，Python官方默认的解释器是CPython，也就是有GIL这个锁特性，当我们运行Python代码时，会通过Python的解释器来执行，当使用CPython解释器时，官方告诉我们，只有获得了GIL锁的才能被执行，也就是每一行Python代码被执行前都要去获得GIL这个全局锁(除了I/O操作)，获得了这个锁，你才可以执行，那么当有多个线程的时候，只会有一个线程获得GIL，也就是只有一个线程会被执行，其他线程都只能傻等着，第一次看到Cpython解释器有这样的特性后，觉得巨坑，后来坑见多了就习惯了

当然上面的解释还太笼统，我查了一些资料，总结一下

用一张摘自David Beazley大神的图来直观的解释一下GIL

![GIL原理图.png](http://obfs4iize.bkt.clouddn.com/GIL%E5%8E%9F%E7%90%86%E5%9B%BE.png)

Python是动态解释性语言，如果解释器是CPython，那么每行python通过解释器解释执行时，都要获得GIL全局锁，当涉及到I/O操作（读写操作）时，会释放GIL锁，如果整段程序没有I/O操作，是CPU密集型操作时(也就是全都是运算操作，不涉及读写)，那么CPython解释器会每隔100 ticks(可以理解为解释器执行了100次操作)就释放GIL，因为有GIL这样的限制，所以有多个线程时也只是分别切换着运行，如上图，并不会发挥出CPU多核的性能

解释器要隔多少次ticks可以通过sys.setcheckinterval来调整(自己没试过:))


其实在Cpython解释器上使用多线程不仅无法提升效率，反而大大的降低效率，通过下面代码来试验一下

```
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import threading
import time

def sum():
	i = 0
	for _ in xrange(100000000):
		i+=1

if __name__ == '__main__':
	t1 = time.time()

	sum()
	sum()

	t2 = time.time()
	
	Thread1 = threading.Thread(target=sum)
	Thread2 = threading.Thread(target=sum)

	t3 = time.time()

	Thread1.start()
	Thread2.start()
	Thread1.join()
	Thread2.join()

	t4 = time.time()

	print '单线程执行CPU密集操作花费时间: %s' % (t2-t1)
	print '多线程执行CPU密集操作花费时间：%s' % (t4-t3)
```

代码逻辑很简单，首先让单个线程执行了两次从0到100000000累加操作，记录起始时间，然后开启两个线程，同样执行两次从0到100000000累加操作，记录起始时间，结果如下图，运行的多次，避免结果不准确

![多线程执行效率.png](http://obfs4iize.bkt.clouddn.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87.png)

可以看出，单线程执行比多线程执行快很多，这也是很多人说python多线程非常鸡肋的原因

造成这样的现象就是因为GIL全局锁，因为是CPU密集操作，所以解释器每个100 ticks就会释放GIL让其他线程去获取，但是**线程释放GIL和获得GIL之间的时间间隔太短**，所以一般当其他线程被唤醒告知可以去获得GIL时，释放GIL的那个线程已经再次获得GIL了，其他被唤醒的线程只能傻看着，然后继续睡觉，这白白浪费了CPU的时间

为了加深理解，直观的解释一下上面代码在CPU里是如何获得GIL并工作的

首先是单个线程执行累加操作，解释器每执行了100 ticks就会让这个线程释放GIL，但是因为是单线程，没有其他线程会被唤醒，该线程会继续获得GIL，然后继续执行，接着一直重复上面的过程，知道累加任务结束

当有两个线程时，解释器同样每执行100 ticks就会让当前线程释放GIL，当当前线程释放了GIL后，解释器发现是多线程的，就会去唤醒其他线程，让其他线程也去获取GIL争夺运行权，但是线程释放GIL和获得GIL之间的时间间隔太短，所以其他线程刚醒，发现GIL已经再次被当前线程获得了，所以只能继续去睡，然后一直重复上面的过程，只有当当前线程执行完自己的任务后，释放GIL不再去抢了，其他线程才能获得GIL去执行自己的任务

从上面的描述中不难看出，多线程**执行CPU密集操作**时，依旧是一个线程不停在执行，根本没有线程之间的切换操作，其实它是想切换不同的线程的，但是释放和获得GIL之间的时间间隔太短了，所以切换不了，反而浪费大量的CPU时间将其他线程唤醒再让其休眠

这可以引发出的思考是，**CPython解释器下python执行多线程适合在I/O操作密集时，而不是CPU操作密集时**，因为I/O操作时，线程会释放GIL，因为I/O是耗时操作，所以当前线程再次获得GIL的机会就小很多了（几乎没可能再次获得），其他线程获得了GIL后就可以执行它的任务了，这样在I/O操作密集的情况下，多线程的效率就会高于单线程的效率（因为单线程会卡在I/O耗时操作上）

## 曲线救国

当时看到GIL时，就想着，牛人那么多，为何不怼烂GIL这个坑货呢？

你可能猜到了，不是怼不烂，是不能怼

CPython解释器的**GIL本意就是让线程之间使用进程的共享内存空间不冲突**，如果要去除GIL，就需要使用跟多粒度更细的锁来实现这个目的，这样要做到多线程安全就比GIL麻烦的多，在当时的历史环境下(谁也没想到CPU可以多核)，GIL是一个合适而且方便的解决方法

同时很多第三方扩展也是使用CPython所谓解释器的，同时依赖GIL这个特性，如果要改，就等于放弃了很第三方扩展，对python打击过大

其实有牛逼的人试过将CPython的GIL去除，加上更多粒度更细的锁，但是测试发现，对单线程程序来说，这个版本的性能大幅下降，只有在利用多核CPU超过一定核数后才有一点优势，这样不奇怪，单线程本来就不需要什么复杂的锁机制，所以一个GIL大锁的性能当然对很多粒度细的小锁性能高。但绝大多数Python程序都是单线程的，所以这样反而不好

正面突破已经不行了，只好曲线救国了

那Python如果才能利用上CPU的多核来提升程序的效率呢？

### 使用多进程代替多线程
这个你应该想到了，既然多线程有GIL这个大锁，那使用多进程不就OK了

每个进程都有一个GIL锁来控制进程中的线程，但是不同的进程之间是没有GIL的，所以开启多个进程，每个进程中使用一个线程则可，这样就可以CPU多核了

python多进程如何使用在上一篇已经讲了，使用multiprocessing 这个多进程标准库则可，使用多进程带来的一个小问题就是，进程之间的通信，**像多线程因为共享进程的内存空间，所以线程之间的通信比较简单，通过变量即可传递信息**，而进程相互之间不共享内存空间，所以就需要通过其他方式来通信了，在python中可以通过multiprocessing模块的Queue和Pipes来通信

### 直接通过C来实现多线程
Python中提供ctypes库，通过ctypes可以让python直接调用C动态库中的导出函数，ctypes会在调用C函数前释放GIL，这样就可以让python通过多线程来发挥CPU多核的计算能力了，我还没使用过ctypes，所以就不多说了，可以自行Google一下ctypes

### 使用其他python解释器，如Jpython、PyPy
GIL并不是python语言的特性，只是CPython解释器拥有的特性，所以使用其他解释器就不会有这样的问题，但是你选择其他解释器，也就放弃了很多第三方库，因为这些第三方库都只能在CPython上运行，CPython解释器支持的第三方库是最多的

同样没有使用过CPython外的其他解释器，so，不发表过多评论

用代码编写乐趣---ayuliao