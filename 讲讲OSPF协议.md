---
title: 讲讲OSPF协议
date: 2016-06-27 15:23:42
tags: 网络协议
---
OSPF，开放最短路径优先，是内部网关协议，是链路状态协议

## OSPF基础部分：
如果管理一个大网络，只能通过OSPF和路由再发布服务（路由再发布是一种能在路由选择协议之间提供转换的服务）

OSPF是基于Dijkstra算法工作的，路由汇聚速度快

### OSPF术语：

**链路：**一个网络或者是一个被指定给任一给定网络的接口，如当一个接口被添加到OSPF线程中，该接口就被人为是链路

**路由器ID：**称RID，在优先级相同的情况下，可以通过比较RID来选举出DR、BDR，RID在有环回接口时，取最大的环回接口IP为RID，没有就取最大的物理接口IP为RID

**区域ID：**OSPF可以划分区域，防止路由器过多，导致网络收敛速度变慢，同时将网络的不稳定限制在单一的网络区域内，同一个区域内的路由器共享一个公共的区域ID，该ID用来标识不同的区域，所有在同一区域内的路由拥有相同的拓扑表，在配置OSPF时，一定要有区域0，区域0通常被认为是主干区域，用来连接不同的区域

**邻居：**路由器某个接口跟另一个路由器的某个接口连接到同一个公共网络，在OSPF中，要成为邻居还有条件，两个路由器要在区域ID，认知OSPF（OSPF允许不同的区域设置密码，要成为邻居，密码要设置的相同）

**邻接：**路由器之间建立邻居关系后，就会进一步建立邻接关系，OSPF只与建立邻接关系的邻居交换共享路由信息，不是所有的邻居都可以建立邻接关系的，要看网络类型和路由器配置

**Hello数据包：**OSPF通过Hello数据包的发送和接收，可以动态的发现邻居，从而建立与符合的路由器建立邻居关系，Hello数据包和链路状态通告（LSA）共同用于建立和维护拓扑数据库

**拓扑数据库：**在同一区域中，当该区域的网络收敛时，该区域的所有路由器都拥有相同的拓扑数据库，作为Dijkstra算法的输入，通过算法为每个网络得到最短路径

**链路状态通告（LSA）：**LSA是一个OSPF数据包，包含着OSPF路由器中共享的链路状态和路由信息，LSA拥有很多不同的类型

**指定路由器（DR）：**为了使建立邻接关系最小化（这里是连接关系，而不是邻居关系，最小化也就是说建立最少的邻接关系），就可以选择一个DR，一个区域内有一个DR，它负责将路由选择信息分发到区域中的路由器上，也就是中转作用，当一个路由器要发送数据信息时，不必跟区域内的所有路由器建立邻接关系，只与DR建立邻接关系，就可以将信息发送给所有区域内符合情况的路由器
DR选举  先比较路由器的优先级，默认是1，谁大选谁为DR
        再比较路由器的RID： 有没有直接用router-id命令设置RID，谁大选谁为DR
        				  有环回接口，比环回接口IP，谁大选谁为DR
						  没有环回接口，比较物理接口IP，谁大选谁

**备用指定路由器（BDR）：**是DR的备份，BDR从OSPF中接收所有的路由更新，但是不泛发LSA更新

**内部路由器**：在OSPF自治系统**单区域**内的路由器

**区域边界路由器（ABR）：**ABR是驻留在单OSPF自治系统内多个区域的路由器

**自治系统边界路由器（ASBR）：**ASBR就是连接多个OSPF自治系统，或连接OSPF自治系统和另外一种路由协议自治系统的路由器

**总结一下：**OSPF用于在单一自治区域（AS，由长度为16位的编码标识）内决策路由，一个AS可有多个区域
			 OSPF的组播地址为224.0.0.5（用于建立邻居关系，DR发送路由信息）和224.0.0.6（路由器发送信息给DR和BDR）

**广播：**允许多个设备连接或访问同一个网络，有将单一数据包投放到网络中所有节点的能力，如以太网，**OSPF中，每个广播多路访问网络都必须选举出一个DR一个BDR

**非广播多路访问：**又称NBMA，如帧中继，X.25和ATM之类的，这些网络运行多路访问，但是没有将单一数据包投放到网络中所有节点的能力，也就是没有广播功能，NBMA网络需要特殊的OSPF配置，并且邻居关系必须详细定义

**点到点和点到多点也不需要DR和BDR**

### OSPF最短路径的计算
在一个区域内，每个路由器都要为同一区域的每个网络计算最短路径，这个计算是基于**拓扑数据库**中收集的信息，并使用最短路径优先算法（SPF），一个区域中的路由器中，它们的拓扑数据库都相同，它们会让自己为树的根节点，通过算法，得到从根节点到不同节点的最短路径，如同一个倒过来的树，这样根到树叶的距离就是该路由器到该网络的最短距离

SPF执行路由处理时重要的标准是某网络的所有可能路径的度量或开销值，SPF只运用于本区域，不适用于其他区域

思科判断路径开销的方法十分简单，使用** 10^8（10的8次方）/ 宽带 **来计算开销，宽带是为接口配置的宽带，利用这个规则，100Mbit/s的快速以太网接口将有一个默认为1的OSPF开销

完整的路径开销：沿这条路径的所有**输出接口**（只是出接口）开销的总和
（宽带为64000的接口的默认开销为1563）

思科是建立于宽带的路径开销的，可以使用**auto-cost reference-bandwidth**命令来改变链路开销的计算公式

	R1(config)#router ospf 100
	R1(config-router)#auto-cost reference-bandwidth 1000


### 说了这么多概念，实践一下

	router(config)#router ospf ?

OSPF可以取的值1~65535，这个数值只具有本地意义，用来识别OSPF进程，路由器也用一个系统，可以把它想象成windows（当然它远没有windows强大）OSPF是其中一个程序拥有一个进程ID，就像在windows开启的一个游戏一样，拥有一个进程ID，进程ID只在本电脑有意义，用来识别不同的进程的，OSPF路由器不需要使用相同的进程ID完成通信，它只是用来标识本地OSPF进程而已

OSPF进程ID用于OSPF数据库中不同实例的识别，只对本地有效，同一台路由器可以配置多个OSPF进程，可以通过重发布实现路由共享，但这样会消耗更多CPU和内存资源

**配置OSPF区域：**

	router#config t
	router(config)#router ospf 1
	router(config-router)#network 10.0.0.0 0.0.0.255 area 0

network用来宣告启用了OSPF协议的接口
network 10.0.0.0 0.0.0.255 area 0 会找路由器上启用了OSPF协议，且接口IP是10.0.0.0~255之间的接口，把它加入区域0

路由器上任何匹配'network'命令中的网络地址的接口都将启用OSPF，可以发送和接收OSPF数据包，高版本的IOS中，可以在接口下通过命令“ip ospf process-id area-id"来激活OSPF的接口

OSPF路由器的接口只用拥有相同的区域ID，才可以成为邻居

**验证OSPF：**

	show ip route

可以看见，O开头的路由（O开头表示它们是OSPF的内部路由）

	show ip ospf

显示在该路由器上全部OSPF进程的信息

配置环回接口：

	router(config)#int loopback 0
	router(config-if)#ip address 172.31.1.1 255.255.255.255

要保证每一个IP都是独立的子网，用32位掩码比较合适，当然其他掩码也行，这样任意两个路由上不使用相同的IP地址就可以了

为路由器配router-id：

	router(config-router)#router-id 172.11.1.1

clear ip ospf process 命令可以让配置的新路由器ID生效，用router-id配置的路由器ID并不会IP地址，只是格式相同罢了
环回接口的IP不能覆盖router-id，先比较优先级，然后再比较router-id-->环回接口IP-->物理接口IP

为路由器修改OSPF默认优先级

	R1#config t
	R1(config)#int f0/0
	R1(config-if)#ip ospf priority 2    //默认为1，越高越优先选择为DR


看发生在广播和非广播多路访问网络上的选举

	R1#debug ip ospf adj

用来这个命令可以看见广播或非广播的多路访问网络中DR和BDR的选举情况

### OSPF的5类报文
OSPF封装在IP报头中，用了交换链路状态广播（Link State Advertisement，LSA）

说说OSPF报头包含的内容：

a.OSPF版本，v3用于IPv6
b.类型OSPF数据类型
c.数据包长度
d.路由器ID：始发路由器的ID
e.区域ID
f.校验和：对整个数据包进行校验
g.身份验证类型：0表示不验证，1表示简单口令验证，2表示MD5验证
h.身份验证：身份验证类型为0，不看该字段，为1，改字段包含最长为64位的口令，为2，该字段包含Key ID、验证数据的长度和一个不会减小的加密序列号

**LSA本身不是OSPF的消息，LSA是一类数据结构，存放在路由器的链路状态库（Link-State DateBase，LSDB）中，可以包含LSU消息进行交换**

**1.Hello**

Hello用于发现邻居，保持邻居之间keeplive，在NBMA中可以选择DR和BDR，默认的Hello报文发送间隔时间是10s，默认无效时间是发送间隔的4倍，40s
其中有的内容：

a.网络掩码
b.Hello间隔
c.路由优先级：用于DR、BDR选举，0~255之间
d.Dead间隔：无效时间，默认40s
e.指定路由DR：DR的路由器接口IP地址，若没有，为0.0.0.0
f.备用指定路由BDR
g.邻居列表

**2.数据库表示（DD或DBD）：**

DBD包含发送方路由器的链路状态摘要（LSA头部信息），接收方接受DBD与本地链路状态数据库进行对比，检查是否同步，一般出现在初始拓扑交换中，可以用来选择主从关系
其中内容：

a.接口MTU：数据不分段可以传输的最大IP数据包的大学
b.I:初始位，发送第一DBD包I位置1，后续DBD包I位置0
c.M:后续位，最后一个DBD包M位置0，其他M位置1
d.MS：主从位，用于协商主\从路由器，置1为主路由器，置0位从路由器
e.DD序列号：在数据库同步过程中，用来确保路由器收到完整DBD数据包，该序列号在**主**路由器发送第一个DBD是设置，或后续数据包的序列号依次增加
f.LSA头部：LSA头部可以唯一识别一个LSA，其中内容为：
		aa.老化时间：发送LSA经历的时间，单位s
		bb.类型：LSA类型
		cc.链路状态ID：标识LSA，LSA类型不同标识方法也不同
		dd.通告路由器：始发LSA通过的路由器ID
		ee.序列号：当LSA被更新时加1，这样可以识别新的LSA
		ff.校验和：出老化时间外，LSA全部信息参与校验
		gg.长度：LSA头部和LSA数据的总长度

**3.链路状态请求（LSR）消息：**

请求一个或多个LSA，当路由器收到DBD包，查看自己的LSDB中不包含哪些LSA或者哪些LSA更新，将这些LSA记录在链路状态请求列表中，通过LSR数据包请求DBD中任何LSA条目的详细信息
其中内容：

a.链路状态类型：LSA的类型
b.链路状态ID：标识LSA，LSA类型不同识别方法也不同
c.通告路由器：始发LSA通告路由器ID

**4.链路状态更新（LSU）消息：**

包含LSA的详细信息，一般用来响应LSR，其中内容有：

1.LSA的数目：更新包中包含的LSA的数量
2.LSAs：一个更新包中可以携带多个LSA

**5.链路状态应答（LSAck）消息：**

用来确认已经收到LSU，多个LSA可以通过一个LSAck来确认

1.LSAck头部

**以上五种消息跟OSPF报头合成了5类OSPF报文**

前面提了那么多次LSA不同类型，那我们来扒一扒LSA有哪些类型？？

1.路由器LSA：每台OSPF路由器都会将路由器LSA发送进与其直连的每个区域，此类LSA描述区域内路由器的链路