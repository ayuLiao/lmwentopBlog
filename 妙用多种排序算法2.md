---
title: 妙用多种排序算法2
date: 2017-03-22 18:22:52
tags: 算法
---

## 简介
在前面那章《妙用多种排序算法》中，已经讲了桶排和冒泡排序这两种方法，其实可以通过一篇的内容将常用的排序算法都介绍完的，但是因为我懒，所以就有了这篇，废话不多说，进入算法的世界

## 快速排序
在前面一章中介绍的桶排和冒泡排序都有比较明显的缺陷，桶排比较耗费空间，但是排序非常快，如果数据离散性不高，桶排是不错的选择，而冒泡排序，那就比较慢了，如果计算机每秒可以进行10亿次运算，选择要对1亿个数进行排序，桶排只需0.1秒（需要很大的内存空间），而冒泡排序需要1千万秒，也就是115天，这是我们不能接受的。

而快速排序算法比较好的综合了上面两种算法的优缺点，快速排序算法的时间复杂度为O(nlogn)，而且不怎么费空间，是比较优秀的排序算法了

快速排序算法的核心思想非常简单，对于一个没有顺序的数字序列，首先找到一个基数，一般将数字序列中的第一个数设置为基数，然后设置两个标兵变量，分别从序列左右两端遍历该序列，让序列左边的数都大于（或小于）基数，让序列右边的数都小于（或大于）基数，当两个标兵相遇时，就将基数赋值到标兵相遇之处，这样序列就被分成两部分，再分别对这两部分进行上面的操作
```
通过快速排序算法使序列成降序排列

没有排序前的序列
6 3 5 2 9 4 7 1

选择6为基数

设置标兵i,j，从左右两端开始遍历

首先j标兵先动，这点很重要，j发现7大于6，接着i标兵才可以动，i发现3小于6，所以7与3交换位置

序列顺序变为
6 7 5 2 9 4 3 1

接着j，i继续遍历，j发现9大于6（j先动），i发现5小于9，所以9和5交换位置，序列的顺序就变为
6 7 9 2 5 3 1

接着j一直往左走，直到与i相遇都没再找到大于6的数，所以j就到了9这个位置，此时j，i相遇，则9与6交换位置，序列的顺序就变为
9 7   6    2 5 3 1

经过一轮遍历后，序列已经分为两部分，比6的部分和比6小的部分，对这两个部分同样通过上面的步骤，最终就可以完成排序了

```
为什么一点要j标兵（右标兵）先动呢？这里可以尝试的让i标兵先动（左标兵），来看一下结果


```

没有排序前的序列
6 3 5 2 9 4 7 1

首先i发现3小于6，j发现7大于6，所以3,7位置交换

序列变为
6 7 5 2 9 4 3 1

i,j这两个标兵继续遍历，i发现5小于6，j发现9大于6，所以5,9交换位置

序列变为
6 7 9 2 5 4 3 1

i,j这两个标兵继续遍历，i,j这两个标兵在2这个位置相遇，所以6与2交换位置

序列变为
2 7 9 6 5 4 3 1

这明显就错了，所以要注意，一定是右标兵先动，这里就是j先动
```

理解了快排的思想后，就会理解为什么快排会比冒泡排序快。相比于冒泡排序，快排的比较都是基于基数的，排序时元素间的交换是跳跃性的，而不像冒泡排序是相邻元素间的交换，这样交换距离大了，交换的总次数却少了，快排在最坏的情况下时间复杂度是O(n^2)，但是快排的平均时间复杂度为O(nlogn)，下面来看一下具体的代码

```c
#include<stdio.h>

int a[100],n;

void FastSort(int left,int right){
	//i,j为标兵数,temp为基数 
	int i,j,t,temp;
	
	if(left>right) return;
	
	//序列中第一个为基数 
	temp = a[left];
	
	i = left;//左标兵 
	j = right;//右标兵 
	
	while(i!=j){
		/**首先j标兵先动，这个顺序很重要
		当这个数小于基数，j标兵才前进，如果大于基数，j标兵就停
		在该位置，等着被交换 
		**/ 
		while(a[j]<=temp && i<j){
			j--;
		} 
		while(a[i]>=temp && i<j){
			i++;
		}
		
		if(i<j){
			t=a[i];
			a[i]=a[j];
			a[j]=t;
		}
	} 
	
	/**
	当i，j标兵相遇时，将相遇位置上的数和基数交换 ，让基数归位 
	**/ 
	a[left] = a[i];
	a[i] = temp;
	
	//递归处理左边的序列 
	FastSort(left,i-1);
	//递归处理右边的序列
	FastSort(i+1,right);
	
} 

int main(){
	int i,j,t;
		
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
		
	FastSort(1,n);
		
	for(i=1;i<=n;i++){
		printf("%d",a[i]);
		printf(" "); 
	}
	return 0;
}
```
排序结果如下
![快排](http://obfs4iize.bkt.clouddn.com/%E5%BF%AB%E6%8E%92.png)

可以看出快排的一个思想就是将大的数列逐渐转换为小的数列，再对小的数列进行排序，这样就提高的排序效率，其实很多算法会用到这样的思想，将大的、较难解决的问题分解成小的、较好解决的问题，通过解决小问题来达到解决大问题的目的

如果想形成升序排列，只需要修改下面的代码
```c
while(a[j]>=temp && i<j){
	j--;
} 
while(a[i]<=temp && i<j){
	i++;
}
```

## 归并排序
归并排序的思想跟快排有些相似，也是将大的问题转成小问题来解决

归并排序讲究的就是将两个或者两个以上的**有序**数列合并成一个新的有序数列，这里要注意，合并之前两个数列就是有顺序的，所以如果给你一个无序的数列，要使用归并排序来序列化该数列，算法的核心就在于分解该数列，排序后再合并

基本的思路就是，将要排序的数列分成两个数列，如果这两个数列自身刚好是有序的，就将这两个序列进行排序，如果这两个序列还是无序的，就再次分解，分解到最后，**一个数列就只有一个数，此时数列自身就是有序的**，再将分解的数列依次合并则可

具体操作如下
1.将n个元素分成各含n/2个元素的子序列
2.用归并排序法对这两个子序列递归地排序
3.合并这两个已经排序好的子序列得到排序结果

直接来看一下具体的代码，代码中有详细的注释
```c
#include<stdio.h>
#include<stdlib.h>

//arr要排序的数组 ,low：数组最左边的下标，high：数组最右边的下标，mid：数组的中间的下标 
void merge(int arr[],int low,int high,int mid){
	int i,k; 
	//动态申请相应大小的空间，作为过度空间，用于合并有顺序的数组 
	int *tmp = (int *)malloc((high-low+1)*sizeof(int));
	//左数组（有顺序） ，通过下标来分出两个数组 
	int left_low = low;
	int left_high = mid;
	//右数组 
	int right_low = mid+1;
	int right_high = high;
	
	//顺序比较两个数组中的数值 
	for(k=0;left_low<=left_high && right_low<=right_high;k++){
		if(arr[left_low]<=arr[right_low]){
			//将两个数组中值较小的存入过度数组tmp中 
			tmp[k]=arr[left_low];
			//左数组下标进一位
			left_low++;
		} else{
			tmp[k]=arr[right_low];
			right_low++;
		}
	}
	
	/**
	如果有数组还有剩余，就将数组中剩余的值，直接添加到过度数组
	的尾部，左右数组不可能同时都有剩余 
	**/
	if(right_low<=right_high) {
		for(i=right_low;i<=right_high;i++){
			tmp[k]=arr[i];
			k++;
		}
	}
	
	if(left_low<=left_high) {
		for(i=left_low;i<=left_high;i++){
			tmp[k]=arr[i];
			k++;
		}
	}
	
	/**
	将过度数组刷回要排序的原始数组中
	此时原始数组就是排列后的有相应顺序的数组了 
	**/
	for(i=0;i<high-low+1;i++){
		arr[low+i] = tmp[i];
	}
	free(tmp);
	return;
}

void mergeSort(int arr[],int first,int last){
	int mid = 0;
	if(first<last){
		mid = (first+last)/2;
		/**递归排序左边的序列。
		左边的序列，会一直递归，直到first=last
		也就是左序列中只有一个数时，自身拥有顺序 
		**/ 
		mergeSort(arr,first,mid);
		mergeSort(arr,mid+1,last);
		merge(arr,first,last,mid);
	}
	return;
} 

int main(){
    int i;
    int a[9]={11,42,52,9,4,20,29,35,88};
    for(i=0;i<9;i++)
        printf("%d ",a[i]);
    printf("\n");
    mergeSort(a,0,8);  // 归并排序
    for(i=0;i<9;i++)
        printf("%d ",a[i]); printf("\n");
    return 0;
}
```

程序运行的结果如图
![归并](http://obfs4iize.bkt.clouddn.com/%E5%BD%92%E5%B9%B6.png)

看着注释来阅读代码，代码的思想应该就不难理解，简单来讲，就是将一个无序的序列一直分解，直到分成一个元素为一个序列，此时该序列自身就有顺序，然后再将这些序列一个个的合并起来，最终形成一个有序的序列，完成递归排序

如果对归并的思想还是有点懵逼，可以看一下下面这幅图
![归并2](http://obfs4iize.bkt.clouddn.com/%E5%BD%92%E5%B9%B62.png)

虽然归并排序和快速排序的时间复杂度都为O(nlogn)，但是一般情况下，归并排序还是要比快速排序快一些些

## 结尾
今天就写到这，学算法一定要有我爱算法，算法爱我的心态，不然啃不下去！